import { __awaiter, __extends, __generator } from "tslib";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { Amplify } from '@aws-amplify/core';
import { InternalGeoClass } from './internals/InternalGeo';
var GeoClass = /** @class */ (function (_super) {
    __extends(GeoClass, _super);
    function GeoClass() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * get the name of the module category
     * @returns {string} name of the module category
     */
    GeoClass.prototype.getModuleName = function () {
        return GeoClass.MODULE;
    };
    /**
     * Search by text input with optional parameters
     * @param  {string} text - The text string that is to be searched for
     * @param  {SearchByTextOptions} options? - Optional parameters to the search
     * @returns {Promise<Place[]>} - Promise resolves to a list of Places that match search parameters
     */
    GeoClass.prototype.searchByText = function (text, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.searchByText.call(this, text, options)];
            });
        });
    };
    /**
     * Search for search term suggestions based on input text
     * @param  {string} text - The text string that is to be search for
     * @param  {SearchByTextOptions} options? - Optional parameters to the search
     * @returns {Promise<SearchForSuggestionsResults>} - Resolves to an array of search suggestion strings
     */
    GeoClass.prototype.searchForSuggestions = function (text, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.searchForSuggestions.call(this, text, options)];
            });
        });
    };
    /**
     * Search for location by unique ID
     * @param  {string} placeId - Unique ID of the location that is to be searched for
     * @param  {searchByPlaceIdOptions} options? - Optional parameters to the search
     * @returns {Promise<Place>} - Resolves to a place with the given placeId
     */
    GeoClass.prototype.searchByPlaceId = function (placeId, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.searchByPlaceId.call(this, placeId, options)];
            });
        });
    };
    /**
     * Reverse geocoding search via a coordinate point on the map
     * @param coordinates - Coordinates array for the search input
     * @param options - Options parameters for the search
     * @returns {Promise<Place>} - Promise that resolves to a place matching search coordinates
     */
    GeoClass.prototype.searchByCoordinates = function (coordinates, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.searchByCoordinates.call(this, coordinates, options)];
            });
        });
    };
    /**
     * Create geofences
     * @param geofences - Single or array of geofence objects to create
     * @param options? - Optional parameters for creating geofences
     * @returns {Promise<SaveGeofencesResults>} - Promise that resolves to an object with:
     *   successes: list of geofences successfully created
     *   errors: list of geofences that failed to create
     */
    GeoClass.prototype.saveGeofences = function (geofences, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.saveGeofences.call(this, geofences, options)];
            });
        });
    };
    /**
     * Get a single geofence by geofenceId
     * @param geofenceId: GeofenceId - The string id of the geofence to get
     * @param options?: GeofenceOptions - Optional parameters for getting a geofence
     * @returns Promise<Geofence> - Promise that resolves to a geofence object
     */
    GeoClass.prototype.getGeofence = function (geofenceId, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.getGeofence.call(this, geofenceId, options)];
            });
        });
    };
    /**
     * List geofences
     * @param  options?: ListGeofenceOptions
     * @returns {Promise<ListGeofencesResults>} - Promise that resolves to an object with:
     *   entries: list of geofences - 100 geofences are listed per page
     *   nextToken: token for next page of geofences
     */
    GeoClass.prototype.listGeofences = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.listGeofences.call(this, options)];
            });
        });
    };
    /**
     * Delete geofences
     * @param geofenceIds: string|string[]
     * @param options?: GeofenceOptions
     * @returns {Promise<DeleteGeofencesResults>} - Promise that resolves to an object with:
     *  successes: list of geofences successfully deleted
     *  errors: list of geofences that failed to delete
     */
    GeoClass.prototype.deleteGeofences = function (geofenceIds, options) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.deleteGeofences.call(this, geofenceIds, options)];
            });
        });
    };
    GeoClass.MODULE = 'Geo';
    return GeoClass;
}(InternalGeoClass));
export { GeoClass };
export var Geo = new GeoClass();
Amplify.register(Geo);
//# sourceMappingURL=Geo.js.map